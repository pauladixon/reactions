the virtual DOM (document object model)

- what is react?
    - react is a front-end js library developed by facebook in 2011.
    - it follows the componenet based approach that helps create reusable UI components
    - it is used to develop a complex and interactive web and mobile interface
    - even though it only became open source in 2015, it has one of the largest communities backing it.
    - it uses the virtual DOM instead of the real DOM
    - it uses server side rendering (backend)
    - it follows the unidirectional data flow or the data binding
    - react native is a mobile framework that compiles into native app components, allowing us to build native mobile apps (iOS, Android, and Windows) in Javascript which allows us to use ReactJS to build our components and implements ReactJS
    - reactJS only covers the user interface layer of an application
- what are the main benefits of using react?
    - it increases performance of the application
    - it can be easily used on the client side as well as the server side
    - high code readability due to jsx
    - easy to integrate with frameworks like meteor, angular, etc.
    - writing user interface tests is easier

- what is the different between the virtual DOM and the real DOM?
    - In React, for every DOM object, there is a corresponding “virtual DOM object.” A virtual DOM object is a representation of a DOM object, like a lightweight copy. A virtual DOM object has the same properties as a real DOM object, but it lacks the real thing’s power to directly change what’s on the screen. Manipulating the DOM is slow. Manipulating the virtual DOM is much faster, because nothing gets drawn onscreen. Think of manipulating the virtual DOM as editing a blueprint, as opposed to moving rooms in an actual house.
    - virtual DOM
        - can't directly update html
        - acts as a copy of the real DOM which can be manipulated and updated with a page refresh
        - more of a pattern than a specific technology
        - synced with the real DOM with 'react-dom'
    - real DOM
        - directly updates and manipulates html
        - creates a new dom / full repaint if it is updated
        - an object based representation of an html document and an interface for maninupating that object
    - the key is 'diffing'
        - the virtual DOM recognizes what needs to be updated and just updates that aspect, from - one state vs the next state
    - is the virtual DOM the same as the shadow DOM?
        - no. the virtual DOM is a pattern that is built into a variety of frameworks including react (and vue)
        - the shadow DOM is useful for styling, for things like making sliders and other built in CSS tools.
        - the shadow DOM is built into browsers and is not a pattern at all.

- react limitations
    - react is a library not a framework - pros and cons 
        - a library is something that enhances your existing code. a big selling point was that you could just use it for small parts within other code.
        - because its a library, it lets you roam free - some people prefer a framework that directs where your files should go. gatsby or next.js are the most popular frameworks that show where your components should go but still uses react
    - react is fairly large
        - if you have guardrails in place its largeness shoudn't effect you too much.
    owned by facebook
        - so it is regularly maintained. it is open  source, yes, but there is a specific team making all the decisions. limitations are privacy (bc facebook) and transparency.
    - the documentation 
        - it's mostly up to date, but it doesn't have enough information on functional components vs class based, even though they're the future of react.
        - the documentation isn't linear and hard to navigate. this means that the learning curve is really difficult.
    - coding can become complex because it uses both inline and JSX models

- jsx
    - bread and butter of react
    - short for javascript xml. (or javascript extension)
    - browsers cannot read jsx
        - browsers can only read javascript objects but jsx is not a standard javascript object
        - browsers can read JSX after transformation to a javascript object using a transformer like babel
    - it allows you to write javascript with an html-like template syntax. this is not the same thing as just putting html in your javascript or writing html or a string that gets inserted into html. 
    - the templates that you use produce elements that represent objects
    - you CAN write react without jsx - you could use React.createElement for all your elements, but using jsx is much easier.
    - difference looks like 
        - ![image](https://i.imgur.com/3oRoTWf.png) 
        - vs 
        - ![image2](https://i.imgur.com/4ZFl7EM.png)
    - difference between an element and a component
        - an element is something that is created by jsx as an object
        - a component is a function that returns an object. components are functions of elements.
        - a react element is what gets returned from components. it's an object that virtually describes the DOM nodes that a component represents.
        - with a function component, this element is the object that the function returns. with a class component, the element is the object that the component's render function returns.


- props (properties)
    - how do you pass a value from parent to child? props.
    - what about from child to parent?
        - pass a function prop.
        - pass a function from parent to child via props. and then that child would call that function, and that function being called would be passed up the the parent.
    - what is prop-drilling?
        - drilling props down a bunch of different components. from grandparent to parent to child etc. continually passing props down via multiple levels
    - can you modify props?
        - no. you can't. props are read-only.
        - the reason is because functions are supposed to be pure components.
        - all react components must act like pure functions with respect to their props. they always return the same output for the same input.
            - pure functions are functions that return identical values for identical arguments.
            - pure components are components that do not rerender when the value or state/props have been updated with the same value.
    - a parent component can pass event handlers as props to child components and then they can be used to handle an event. thus we say that an event raised in a child component can be handled in a parent component.

- state and lifecycle
    - what is the difference between props and state?
        - both are js objects. both hold information that influences what will be rendered, but props get passed to a component (kind of like function parameters), while state is mananged within a given component. 
        - state is 
            - kind of like variables declared within a function. they are scoped within that function. state is local to a given component. you cannot access state outside a given component unless you pass it with props. it is completely inside, scoped and local, within a given component.
            - state is an internal data store (object) of a component as well as a permanent storage.
            - to update state in react forcefully, use forceUpdate
            - setState
                - the second argument is to call code after the setState operation is complete
                - when the new state is dependent on the old state, it is recommended to pass this.setState as a function instead of as an object.
    - what is the difference between state in a class component vs state in a function component?
        - for state in a class component, you use a function called this.getState(). this is something that is attached to a class object. the component in a react class is an object and the state is something that persists across that class component.
        - state in a function component is something that is recalled multiple times. because a function component isn't an object that persists over time, where its something that you manipulate. it is something that is recalled over time, every single time state changes. that is the high level answer
        - state persists in a class component, state is recalled in a function component.
        - a component can only return one element.
    - what is the component lifecycle? 
        - state kind of controls the component lifecycle
        - mounting (first appearance)
            - render, componentDidMount
        - updating (because state has changed)
            - render, componentDidUpdate
        - unmounting (remove event listener, etc)
            - componentWillUnmount
    - how do you update the lifecycle in function components?
        - use the hook useEffect to update state

- effects
    - what parameters does useEffect take in?
        - a function and a dependency array that determines when the function (the effect) will be run.
    - when does the useEffect function run?
        - on mount, whenever things update - simple answer
        -  complex answer depends on the dependency array
            - [] -> runs on mount
            - [variable] -> runs on mount and when the variable changes
            - no array -> runs on mount and on every state change.
    - what is the useEffect function's return value?
        - the return value is called a cleanup function. and that cleanup function is something that cleans up any event listeners, any fetch cancellation types of things. it says 'hey the component is about to unmount'
        - you can update state variables etc inside the function, but the cleanup function is called when the component is about to unmount.
        - useEffect is very useful because it can cover every single one of the lifecycle methods in a much more concise way. it is very powerful.

- refs
    - what is the difference between refs and state variables?
        - they are very similar 
        - both are objects that can contain values, but state variables are something that can trigger a rerender, while refs cannot. refs have a value that persists across renders - they can just hold on to something you might need.
    - when is the best time to use a ref?
        - it literally says in the react documentation to not overuse them, but:
            - great for library authors - where info remains stagnant. 
            - managing focus or media
                - use a ref to focus the input element on a modal?
            - triggering animations
                - something that is imperative and not state-driven
            - integrating with DOM libraries
                - ref gives 3rd party libraries something to grab on to for the DOM since the virtual DOM does not.
    - what is the proper way to update a ref in a function component?
        - if you need to update a ref, useEffects to do so.
    - refs are used to assign references to DOM elements. refs can be created by:
        - calling the react.createref method
        - assigning a value to the ref attribute in JSX

- context 
    - what is the difference between Context API and prop drilling? (this is a very common question)
        - first of all, prop drilling is for explicitly stating props and values that a given child component can get.
        - meanwhile, the context API implicitly states what values a given child component can have. with the context api, you define something at the top level and put those values in at the top level, and then anything inside that component tree, anything that is within a given context at the top has access to the values that you give it.
        - props need to be passed from component to component to component. with this, you know exactly where certain values are being passed at any give time,  but you those values also can be manipulated on accident.
        - but with a context api, beacuse the values are defined at the top level and can be accessed/manipulated at any level of the tree, you might have some unncessary rerenders. something to be aware of.
    - when shouldn't you use the context api?
        - you shouldn't overuse it. be discerning to avoid rerenders. 
        - i would only put what's absolutely necessary at the top level of my application with context. everything else i would just make more context apis if they need to be shared, otherwise props are a perfectly good way of sharing different state values and refs.
        - context is really useful for things like authentication or a website theme or something that really needs to be shared across an application tree, but its not something you need to keep track of a lot of different clicks or something.
        - this is somethign that came out of redux popularity but led to a lot of rerenders.

- misc.
    - what is a fragment?
        - kind of nothing. they're containers to hold onto different elements. with react you need to return only one element every single time 
        - these are to avoid 10 layer divs and how that can mess up design elements. makes sure you're only returning one individual thing.
    - when should you use a class based component vs function components?
        - class components are becoming outdated and function components are the future of react. all the new features of react are geared toward function based components. 
        - the only thing you absolutely need to use class based components for is 'error boundaries'. 
            - error boundaries are react components that catch javascript errors anywhere in the child component tree. they log those errors, they display a fallback UI instead of the component tree that crashed. 
            - they catch a lot of errors during rendering and in lifecycle methods and in constructors of the entire tree below them. they're pretty neat, but you need class based components for them because there aren't any hooks geared for them yet.
        - function components are light weight and faster than class based components.
    - what is a higher ordered component (HOC)?
        - this is a function that takes IN a component and it returns a new component. it is used for reusing component logic and it isn't a react API thing its just a pattern that emerged within react.
    - what is a portal?
        - a way to render children into a DOM node that exists outside of the DOM hierarchy of the parent component. it can live anywhere in the DOM tree and you most often see it in UI components like modals where the modal lives separately from the entire tree of different components containing each other.
    - what are controlled and uncontrolled components?
        - uncontrolled components are input values - some sort of user manipulated component. something that the user controls and not that react controls. 
        - controlled components are a solution to the potential discrepancies between the virtual DOM and the real DOM (if you had jQuery and React on the same site, for instance). where you have a given input and react controls it 
            - react controls the state changes happening in it and reacts to those state changes. it is the thing that contains that component. jquery can't touch it, and react can prevent a user from interacting with it.
        - to upload a file from a react component, a developer must write an uncontrolled component. a file upload cannot be done from a controlled component because it requires user input.
    - what is the render() method in react?
        - it returns a single react element while is the representation of the native DOM component.
    - what are the differences between react and angular?
        - in react, the render is built on the server side instead of with angular where the render is built on the client side
        - in react there is only a one-way data link, but with angular there is a bi-directional data link
    - keys
        - keys are given to a list of elements in react. these keys should be unique among the siblings only
        - used to improve performance
    - babel is both a compiler and a transpiler
    - 8080 is the webpack dev server
    - webpack commands act as a mondule bundler
    - convert from a class based component to a function based component:
        - ![image3](https://i.imgur.com/VoPouej.png) vs ![image4](https://i.imgur.com/kEYdtFv.png)
